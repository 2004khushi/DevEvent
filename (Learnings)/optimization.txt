This file is created to tell about the optimization I have done and why I did it ->

1) Cloudinary ->

Permanent Storage: Next.js runs on a "read-only" file system when deployed (like on Vercel). You cannot save a user's uploaded file directly to your project folder. Cloudinary acts as the "cloud hard drive" that keeps those images forever.

Saving Server Power: Next.js uses your server's CPU to resize images. If 100 users upload large photos at once, your site could crash or slow down. Cloudinary does all that heavy processing on its own servers.

has mart Features

The "Public URL" Benefit: Having a public URL means you only need to store a small string of text in your database (e.g., https://cloudinary.com/my-image.jpg) instead of the actual heavy image data. This makes your database fast and lightweight.

Now here u may ask since next is a full stack and like easy integration with mongoose and all that db then why not just use that then this...
well teh answer is If you store a 5MB image in Mongoose, every time a user views it on a tiny mobile screen, they have to download all 5MB.
With Cloudinary, You just add w_300 to the URL. Cloudinary creates a 300px version instantly and sends only 20KB to the phone.
Doing this manually with Mongoose would require you to write complex code to resize the image every time someone uploads it.

Also, bcs cloudinary uses CDN -> When a user in London requests an image, it is served from a server in London. When someone in New Delhi requests it, it comes from a server in New Delhi. A database cannot do this.
One more issue with mongoose and all -> The Problem: A single high-res smartphone photo is about 5MB. In database terms, that is massive.
            The Result: Your database backups will take hours, your queries will slow down, and your hosting costs (MongoDB Atlas, etc.) will skyrocket because you are paying for premium "high-speed" storage for "heavy" static files.



2. Connection Pooling Optimization (mongodb.ts)
In a standard Next.js setup, every time you save a file and the server "hot-reloads," the code runs again.

Without the cache: Every reload creates a brand new connection. Eventually, MongoDB will say, "Sorry, you have 100 open connections, I can't give you any more," and your app will crash (Connection Pool Exhaustion).

With the cache: You are reusing the exact same connection across reloads. Itâ€™s like keeping a phone call active instead of hanging up and redialing every 5 seconds.


3. The "Thundering Herd" Optimization (Race Conditions) (mongodb.ts)
This refers to the cached.promise part of your code.

The Problem: When your website starts up, you might have 5 different components all calling connectDB() at the same time.

Without the promise cache: You would launch 5 simultaneous requests to MongoDB.

With the promise cache: The first request starts the "handshake." The other 4 requests see the promise is already in progress and they just wait for that same promise. This saves CPU, memory, and network bandwidth.